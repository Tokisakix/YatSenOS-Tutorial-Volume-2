# 实验三：内核线程与缺页异常

!!! danger "在执行每一条命令前，请你对将要进行的操作进行思考"

    **为了你的数据安全和不必要的麻烦，请谨慎使用 `sudo`，并确保你了解每一条指令的含义。**

    **1. 实验文档给出的命令不需要全部执行**

    **2. 不是所有的命令都可以无条件执行**

    **3. 不要直接复制粘贴命令执行**

## 进程模型设计

在不同的操作系统中，进程模型的设计各有千秋。在 macOS xnu 和 Windows NT 内核中，线程是调度执行的基本单位，进程是资源分配的基本单位，线程通过共享进程所描述的一系列资源来互相协作。而在 Linux 内核中，没有线程的相关概念，而进程也同时是调度执行的基本单位，通过一些特殊的机制来实现进程间的协作和资源共享。有关进程模型的区别、设计在理论课上有详细的讲解，这里不再赘述。

进程的实现和调度是（抢占式）操作系统的核心，在本实验所要实现的操作系统中将采用和 Linux 设计相近的进程模型设计理念，即进程也是被调度的单位。下图是本实验的进程模型设计示意图。**实验并不会一次将它完全实现，很多部分将在未来的实验中逐步补全，在这里希望大家能有一个整体性的理解，并在实现的过程中明确自己当前在做什么**：

![](../assets/proc.png)

### 进程控制块

进程控制块（Process Control Block，PCB）是操作系统中用于描述进程的一种数据结构，它包含了进程的所有信息。

在实验中，我们使用 `Process` 结构体表示一个进程，它含有 `pid` 和 `inner` 两个字段，分别表示进程的 ID 和内部数据。`inner` 字段是一个 `Arc<RwLock<ProcessInner>>` 类型的智能指针，它指向了一个 `ProcessInner` 结构体，这个结构体包含了进程的其他信息，包括进程的状态、调度计次、退出返回值、内存空间、父子关系、中断上下文、文件描述符表等等。

!!! note "`RwLock` 读写锁"

    `RwLock` 读写锁允许多个线程同时读取数据，但只允许一个线程写入数据。

    多个线程可以同时通过 `read()` 获取读锁，对数据进行读取操作，但只有一个线程可以通过 `write()` 获取写锁，对数据进行写入操作。当有线程获取写锁时，所有的读锁都会被阻塞，直到写锁被释放。

!!! note "`Arc` 原子引用计数智能指针"

    `Arc` 是 `alloc::sync` 中的一个原子引用计数智能指针，它允许多个线程同时拥有对同一数据的所有权，且不会造成数据竞争。

    `Arc` 的 `clone()` 方法会增加引用计数，`drop()` 方法会减少引用计数，当引用计数为 0 时，数据会被释放。`Arc` 本身是**不可变的**，但可以通过 `RwLock` 获取内部可变性，进而安全的修改一个被多个线程所持有的数据。

进程有一个唯一标识符：`pid`，实验使用 `struct ProcessId(pub u16)` 进行实现，在最基本的实现中，只需要保证每一次 `ProcessId::new()` 调用都会返回一个不同的 `ProcessId` 即可。

对于 `ProcessInner` 结构体，在后面的实验中将逐步补全和解释它的实现。

### 进程上下文

在抢占式操作系统中，进程的调度是通过中断来实现的。当一个进程的时间片用完后，操作系统会触发一个时钟中断，进程调度器会被唤醒，它会根据进程的状态和调度策略来决定下一个要运行的进程。在调度器决定好下一个要运行的进程后，它会将当前进程的上下文保存起来，然后将下一个进程的上下文恢复，从而使得下一个进程得以运行。

在之前的实验中，已经描述过在 x86_64 架构下的中断发生时，CPU 会将当前的一部分上下文保存到内核栈中，然后跳转到中断处理函数。这些上下文包括：

- `instruction_pointer`：指令指针，保存了中断发生时 CPU 正在执行的指令的地址。
- `code_segment`：代码段寄存器，保存了当前正在执行的代码段的选择子。
- `cpu_flags`：CPU 标志寄存器，保存了中断前的 CPU 标志状态。
- `stack_pointer`：栈指针，保存了中断前的栈指针。
- `stack_segment`：栈段寄存器，保存了中断前的栈段选择子，在 x86_64 下总是为 0。

而在进行进程切换时，通常还需要保存和恢复更多的上下文，这些内容主要包括通用寄存器和浮点寄存器。为了简化实现，实验在编译架构选项中禁用了浮点寄存器，因此只需要保存和恢复通用寄存器即可。

!!! question "所有通用寄存器都需要保存吗？"

    如果完全按照调用约定，并不是全部寄存器都应当在中断发生和进程切换时被保存。

    但是在实验中，为了简化实现，我们将所有通用寄存器都保存到了进程上下文中。

在 `src/utils/regs.rs` 中，实现了寄存器的保存和恢复，并为寄存器声明了自己的结构体。

这里解释一下 `as_handler` 宏的实现：

```rust
#[macro_export]
macro_rules! as_handler {
    ($fn: ident) => {
        paste::item! {
            #[naked]
            pub extern "x86-interrupt" fn [<$fn _handler>](_sf: InterruptStackFrame) {
                unsafe {
                    core::arch::asm!("
                    push rbp
                    // ...
                    push r15
                    call {}
                    pop r15
                    // ...
                    pop rbp
                    iretq",
                    sym $fn, options(noreturn));
                }
            }
        }
    };
}
```

`as_handler` 宏接受一个函数名作为参数，它会生成一个函数名为 `[函数名]_handler` 的函数，中断栈本身会包含 `InterruptStackFrame` 作为参数（`x86-interrupt` 调用约定中实现），而我们需要保存更多寄存器到栈上，因此使用 `naked` 属性来禁用 Rust 的栈帧生成，然后使用汇编代码来手动保存和恢复寄存器。

在保存了寄存器后，使用 `call` 指令调用原函数，然后恢复寄存器，使用 `iretq` 指令返回。

在此宏进行转换后，我们使用如下的方式声明并使用一个中断处理函数：

```rust
pub unsafe fn reg_idt(idt: &mut InterruptDescriptorTable) {
    idt[/* ... */].set_handler_fn(teapot_handler);
}

pub extern "C" fn teapot(mut context: ProcessContext) {
    // do something
}

as_handler!(teapot);
```

`extern "C"` 用于指定函数使用 C 语言的调用约定，使得这一函数不会被编译器内联或使用 Rust 函数命名规范，从而能够正确导出符号参与编译器链接。

对于参数部分，`ProcessContext` 的简单声明如下：

```rust
#[repr(C)]
pub struct ProcessContextValue {
    pub regs: RegistersValue,
    pub stack_frame: InterruptStackFrameValue,
}
```

这里的 `ProcessContextValue` 命名和相关的保护处理方法来自 `InterruptStackFrame` 的内部实现，用以防止意外的修改及其导致的非预期行为。

`repr(C)` 用于指定使用 C 语言的结构体布局，以便于在汇编代码中正确处理结构体的字段。

### 进程页表

进程的页表是通过向 `Cr3` 寄存器写入页表的物理地址来实现控制的，因此在进程切换时，需要将进程的页表物理地址写入 `Cr3` 寄存器。

除了内核进程的页表在启动时被初始化外，其他进程的页表都是在进程创建时被初始化的。它们通常通过克隆内核进程来实现，这样做的目的是当程序陷入中断时，CPU 能够正常访问到内核的代码和数据，从而能够正常的进行系统调用。

!!! question "如何克隆一个页表？"

    x86_64 架构下的四级页表是一个树形结构，进而能够映射到很大的虚拟地址空间，且不需要很大的内存开销。

    我们假设**页表的页面在映射后不会被修改**，且用户进程的地址空间和内核地址空间有一定的差距，一般的实现是将内核映射到很高的地址空间，而用户进程映射到较低的地址，这一点可以从 lab 1 的映射中看出。

    在这样的假设下克隆页表的过程中，就不需要将整棵页表树都复制一遍，只需要复制根节点即可。

在后续有关用户进程的实现中，还会遇到有关页表共享的问题，这里暂时不作展开。
